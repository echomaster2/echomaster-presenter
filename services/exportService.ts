import { StoryboardScene } from "../types";

// Helper to remove formatting characters for canvas rendering
const cleanText = (text: string) => text.replace(/\*\*/g, '').replace(/\*/g, '');

export const downloadStoryboardCollage = async (title: string, scenes: StoryboardScene[]) => {
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');
  if (!ctx) return;

  // Configuration
  const width = 1200;
  const padding = 40;
  const gap = 40;
  const headerHeight = 140; // Increased for better title spacing
  
  // Layout calculation
  const columns = 2;
  const cardWidth = (width - (padding * 2) - (gap * (columns - 1))) / columns;
  const imageHeight = cardWidth * (9/16);
  const textPadding = 20;
  const captionFontSize = 20;
  const captionLineHeight = 30;
  const estimatedLines = 4; // Estimate space for caption
  const textHeight = (textPadding * 2) + (captionLineHeight * estimatedLines); 
  const cardHeight = imageHeight + textHeight;
  
  const rows = Math.ceil(scenes.length / columns);
  const height = headerHeight + (rows * cardHeight) + ((rows - 1) * gap) + padding;

  canvas.width = width;
  canvas.height = height;

  // Background
  ctx.fillStyle = '#0f172a'; // Slate 900
  ctx.fillRect(0, 0, width, height);

  // Header Background
  ctx.fillStyle = '#1e293b'; // Slate 800
  ctx.fillRect(0, 0, width, headerHeight - 20);

  // Title
  ctx.fillStyle = '#f8fafc'; // Slate 50
  ctx.font = 'bold 48px Inter, sans-serif';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(title, width / 2, (headerHeight - 20) / 2);

  // Subtitle/Footer
  ctx.fillStyle = '#94a3b8';
  ctx.font = '16px Inter, sans-serif';
  ctx.fillText("Generated by AudioVisio", width / 2, (headerHeight - 20) / 2 + 40);

  // Helper to load image
  const loadImage = (url: string): Promise<HTMLImageElement> => {
    return new Promise((resolve, reject) => {
      const img = new Image();
      img.crossOrigin = "anonymous";
      img.onload = () => resolve(img);
      img.onerror = (e) => {
        console.warn("Failed to load image for canvas", url, e);
        // Resolve with empty image or placeholder to prevent crash
        resolve(new Image());
      };
      img.src = url;
    });
  };

  // Draw Scenes
  ctx.textAlign = 'left';
  ctx.textBaseline = 'alphabetic';

  for (let i = 0; i < scenes.length; i++) {
    const scene = scenes[i];
    const col = i % columns;
    const row = Math.floor(i / columns);
    
    const x = padding + (col * (cardWidth + gap));
    const y = headerHeight + (row * (cardHeight + gap));

    // Card Background
    ctx.fillStyle = '#1e293b'; // Slate 800
    ctx.fillRect(x, y, cardWidth, cardHeight);

    if (scene.imageUrl) {
      try {
        const img = await loadImage(scene.imageUrl);
        if (img.width > 0) {
           // Draw image
           ctx.drawImage(img, x, y, cardWidth, imageHeight);
        } else {
            // Draw placeholder
            ctx.fillStyle = '#334155';
            ctx.fillRect(x, y, cardWidth, imageHeight);
            ctx.fillStyle = '#64748b';
            ctx.textAlign = 'center';
            ctx.font = 'italic 20px Inter, sans-serif';
            ctx.fillText("Image Unavailable", x + cardWidth/2, y + imageHeight/2);
            ctx.textAlign = 'left'; // Reset
        }
      } catch (e) {
        console.error("Error drawing image", e);
      }
    }

    // Border around image
    ctx.strokeStyle = '#334155'; // Slate 700
    ctx.lineWidth = 1;
    ctx.strokeRect(x, y, cardWidth, imageHeight);

    // Scene Badge
    ctx.fillStyle = 'rgba(0,0,0,0.7)';
    ctx.fillRect(x + 10, y + 10, 90, 34);
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 14px Inter, sans-serif';
    ctx.fillText(`SCENE ${i+1}`, x + 22, y + 32);

    // Caption Text
    ctx.fillStyle = '#e2e8f0'; // Slate 200
    ctx.font = `${captionFontSize}px Inter, sans-serif`;
    
    // Clean formatted text for canvas
    const plainCaption = cleanText(scene.caption);
    const words = plainCaption.split(' ');
    let line = '';
    let lineY = y + imageHeight + 40;
    const maxWidth = cardWidth - (textPadding * 2);

    for(let n = 0; n < words.length; n++) {
      const testLine = line + words[n] + ' ';
      const metrics = ctx.measureText(testLine);
      const testWidth = metrics.width;
      if (testWidth > maxWidth && n > 0) {
        ctx.fillText(line, x + textPadding, lineY);
        line = words[n] + ' ';
        lineY += captionLineHeight;
      }
      else {
        line = testLine;
      }
    }
    ctx.fillText(line, x + textPadding, lineY);
  }

  // Trigger Download
  try {
      const link = document.createElement('a');
      link.download = `${title.replace(/[^a-z0-9]/gi, '_').toLowerCase()}_storyboard.png`;
      link.href = canvas.toDataURL('image/png');
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
  } catch(e) {
      console.error("Failed to download canvas", e);
      alert("Could not export image. This might be due to security restrictions on the images used.");
  }
};

/**
 * Renders a video (WebM) from the audio and storyboard scenes using MediaRecorder.
 * This happens in real-time playback speed.
 */
export const renderVideo = async (
  audioBlob: Blob,
  scenes: StoryboardScene[],
  onProgress: (percent: number) => void,
  checkCancelled: () => boolean
): Promise<Blob | null> => {
  
  // 1. Prepare Assets
  const audioUrl = URL.createObjectURL(audioBlob);
  const audio = new Audio(audioUrl);
  audio.crossOrigin = "anonymous";
  
  // Wait for audio metadata to get duration
  await new Promise<void>((resolve) => {
    audio.onloadedmetadata = () => resolve();
    // Trigger load
    audio.load();
  });
  
  const duration = audio.duration;
  if (!duration || duration === Infinity) {
    // Fallback if duration issue
    console.warn("Could not determine audio duration");
  }

  // Load all images
  const loadedImages: HTMLImageElement[] = await Promise.all(
    scenes.map(async (scene) => {
      const img = new Image();
      img.crossOrigin = "anonymous";
      if (scene.imageUrl) {
        img.src = scene.imageUrl;
        await new Promise((resolve) => {
          img.onload = resolve;
          img.onerror = resolve; // Continue even if error
        });
      }
      return img;
    })
  );

  // 2. Setup Canvas & Context
  const canvas = document.createElement('canvas');
  canvas.width = 1920;
  canvas.height = 1080;
  const ctx = canvas.getContext('2d');
  if (!ctx) {
      URL.revokeObjectURL(audioUrl);
      throw new Error("Could not create canvas context");
  }

  // Fill black initially
  ctx.fillStyle = '#000';
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // 3. Setup Audio Context for stream capture (to silence output but record it)
  const audioCtx = new (window.AudioContext || (window as any).webkitAudioContext)();
  const source = audioCtx.createMediaElementSource(audio);
  const dest = audioCtx.createMediaStreamDestination();
  const gainNode = audioCtx.createGain();
  
  // Connect: source -> gain (mute for user) -> speakers (so it plays but is silent)
  // Connect: source -> dest (for recorder)
  
  source.connect(gainNode);
  gainNode.connect(audioCtx.destination);
  gainNode.gain.value = 0; // Mute speaker output
  
  source.connect(dest);

  // 4. Setup Recorder
  const canvasStream = canvas.captureStream(30); // 30 FPS
  const combinedStream = new MediaStream([
      ...canvasStream.getVideoTracks(),
      ...dest.stream.getAudioTracks()
  ]);

  const chunks: BlobPart[] = [];
  // Use vp9 for better quality if available, else standard webm
  let mimeType = 'video/webm;codecs=vp9';
  if (!MediaRecorder.isTypeSupported(mimeType)) {
      mimeType = 'video/webm';
  }
  
  const recorder = new MediaRecorder(combinedStream, {
    mimeType,
    videoBitsPerSecond: 5000000 // 5 Mbps
  });

  recorder.ondataavailable = (e) => {
    if (e.data.size > 0) chunks.push(e.data);
  };

  return new Promise<Blob | null>((resolve, reject) => {
    
    recorder.onstop = () => {
      // Cleanup
      audio.pause();
      source.disconnect();
      dest.disconnect();
      gainNode.disconnect();
      audioCtx.close();
      URL.revokeObjectURL(audioUrl);
      
      if (checkCancelled()) {
          resolve(null);
          return;
      }
      
      const blob = new Blob(chunks, { type: mimeType });
      resolve(blob);
    };

    recorder.start();
    audio.play();

    // 5. Render Loop
    const renderLoop = () => {
      if (checkCancelled()) {
        recorder.stop();
        return;
      }

      if (audio.paused || audio.ended) {
        if (recorder.state === 'recording') recorder.stop();
        return;
      }

      const currentTime = audio.currentTime;
      const progress = (currentTime / duration) * 100;
      onProgress(progress);

      // Find current scene
      let currentImg = loadedImages[0];
      let currentCaption = scenes[0]?.caption || "";
      
      for (let i = 0; i < scenes.length; i++) {
        if (currentTime >= (scenes[i].timestamp || 0)) {
           currentImg = loadedImages[i];
           currentCaption = scenes[i].caption;
        } else {
           break;
        }
      }

      // Draw Background
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      if (currentImg && currentImg.src) {
        // "Contain" logic for image
        const scale = Math.min(canvas.width / currentImg.width, canvas.height / currentImg.height);
        const x = (canvas.width / 2) - (currentImg.width / 2) * scale;
        const y = (canvas.height / 2) - (currentImg.height / 2) * scale;
        
        ctx.drawImage(currentImg, x, y, currentImg.width * scale, currentImg.height * scale);
      }

      // Draw Subtitles (Optional)
      if (currentCaption) {
          ctx.fillStyle = 'rgba(0,0,0,0.7)';
          // Draw box
          const fontSize = 40;
          ctx.font = `bold ${fontSize}px sans-serif`;
          ctx.textAlign = 'center';
          
          // Use cleaned text for width measurement and drawing
          const plainCaption = cleanText(currentCaption);
          
          const textWidth = ctx.measureText(plainCaption).width;
          const boxWidth = Math.min(textWidth + 60, canvas.width - 100);
          
          // Simple multiline logic if needed, but for now simple wrap or single line
          const bottomY = canvas.height - 80;
          ctx.fillRect((canvas.width/2) - (boxWidth/2), bottomY - fontSize - 20, boxWidth, fontSize + 40);
          
          ctx.fillStyle = '#fff';
          ctx.fillText(plainCaption, canvas.width / 2, bottomY - 20, boxWidth - 40);
      }
      
      requestAnimationFrame(renderLoop);
    };

    renderLoop();
  });
};